では下記のコードを管理しやすく整理してください。変更が必要なファイルも教えてください。
//content.js

// // ===== 定数と設定 =====

// グローバル変数

let latestBlob = null;

let slidePreviewImages = []; // スライドのプレビュー画像を保存する配列

// ===== プレビュー関連の関数 =====

// プレビュー用パネルを作成

// ===== 自動更新機能 =====

// 前回検出したJSONデータを保存する変数

let lastDetectedJson = null;

let autoUpdateEnabled = true; // 自動更新の有効/無効フラグ

let observerActive = false; // オブザーバーがアクティブかどうか

let observer = null; // MutationObserverのインスタンス

// MutationObserverを使用してページの変更を監視する関数

function startJsonAutoDetection() {

  if (observerActive) return; // すでに監視中なら何もしない

  

  console.log('JSON自動検出を開始します');

  

  // 前回のJSONを保存

  lastDetectedJson = getJsonFromPage();

  

  // MutationObserverの設定

  observer = new MutationObserver((mutations) => {

    // プレビューパネルが表示されているか確認

    const previewPanel = document.getElementById('pptx-preview-panel');

    if (!previewPanel || !autoUpdateEnabled) {

      // プレビューパネルが表示されていないか、自動更新が無効なら処理しない

      return;

    }

    

    // 変更があったらJSONを検出

    const jsonData = getJsonFromPage();

    

    // JSONが見つかり、前回と異なる場合は更新

    if (jsonData && jsonData !== lastDetectedJson) {

      console.log('新しいJSONデータを検出しました。プレビューを更新します。');

      lastDetectedJson = jsonData;

      

      // プレビューを更新

      updatePreviewWithJson(jsonData);

    }

  });

  

  // ページ全体の変更を監視

  observer.observe(document.body, {

    childList: true,

    subtree: true,

    characterData: true

  });

  

  observerActive = true;

  console.log('JSON自動検出が有効になりました');

}

// 監視を停止する関数

function stopJsonAutoDetection() {

  if (observer && observerActive) {

    observer.disconnect();

    observerActive = false;

    console.log('JSON自動検出を停止しました');

  }

}

// プレビューパネルの作成関数を修正

function createPreviewPanel() {

  // 既存のパネルがあれば削除

  const existingPanel = document.getElementById('pptx-preview-panel');

  if (existingPanel) {

    existingPanel.remove();

  }

  

  // ページを左に詰めるクラスを追加

  document.body.classList.add('pptx-preview-active');

  

  // パネル本体

  const panel = document.createElement('div');

  panel.id = 'pptx-preview-panel';

  

  // ヘッダー

  const header = document.createElement('div');

  header.className = 'pp-header';

  header.innerHTML = `<h3>PPT Gen</h3>`;

  panel.appendChild(header);

  

  // 閉じるボタン

  const closeBtn = document.createElement('button');

  closeBtn.textContent = '×';

  closeBtn.className = 'pp-close-btn';

  closeBtn.onclick = () => {

    panel.remove();

    // ページを元に戻す

    document.body.classList.remove('pptx-preview-active');

    // パネルが閉じられたら監視を停止

    stopJsonAutoDetection();

    // ボタンの状態を更新

    const toggleBtn = document.getElementById('pptx-preview-toggle');

    if (toggleBtn) {

      toggleBtn.classList.remove('panel-open');

    }

    isPanelVisible = false;

  };

  header.appendChild(closeBtn);

  

  // ボタンコンテナ（ボタンを横に並べるため）

  const buttonContainer = document.createElement('div');

  buttonContainer.className = 'pp-button-container';

  header.appendChild(buttonContainer);

  

  // 自動更新トグルボタン - テキストのまま

  const autoUpdateBtn = document.createElement('button');

  autoUpdateBtn.id = 'pptx-auto-update-btn';

  autoUpdateBtn.textContent = autoUpdateEnabled ? '自動更新: ON' : '自動更新: OFF';

  autoUpdateBtn.className = autoUpdateEnabled ? 'auto-update-on' : 'auto-update-off';

  autoUpdateBtn.onclick = () => {

    autoUpdateEnabled = !autoUpdateEnabled;

    autoUpdateBtn.textContent = autoUpdateEnabled ? '自動更新: ON' : '自動更新: OFF';

    autoUpdateBtn.className = autoUpdateEnabled ? 'auto-update-on' : 'auto-update-off';

    if (autoUpdateEnabled) {

      showUpdateNotification('自動更新が有効になりました');

      // 最新のJSONを取得して保存

      lastDetectedJson = getJsonFromPage();

    } else {

      showUpdateNotification('自動更新が無効になりました');

    }

  };

  buttonContainer.appendChild(autoUpdateBtn);

  

  // 更新ボタン - アイコン化

  const refreshBtn = document.createElement('button');

  refreshBtn.id = 'pptx-refresh-btn';

  refreshBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>';

  refreshBtn.title = '更新';

  refreshBtn.onclick = async () => {

    try {

      // ページからJSONデータを取得

      const jsonData = getJsonFromPage();

      if (jsonData) {

        // JSONデータが見つかった場合、それを使用

        console.log('📄 [content.js] ページからJSONデータを取得:', jsonData);

        lastDetectedJson = jsonData; // 最新のJSONを保存

        // PPTX生成

        const pptx = new PptxGenJS();

        pptx.defineLayout({ 

          name: 'myLayout', 

          width: SlideCreator.LAYOUT_WIDTH, 

          height: SlideCreator.LAYOUT_HEIGHT 

        });

        pptx.layout = 'myLayout';

        // マスター定義

        // ロゴのパスを取得（拡張機能内のリソース）

        const logoPath = chrome.runtime.getURL('logo.png');

        SlideCreator.defineMasterSlide(pptx, logoPath);

        // JSONデータからスライドを生成

        const success = SlideCreator.createSlidesFromJson(pptx, jsonData, false);

        if (!success) {

          // 失敗した場合はデフォルトのスライドを使用

          alert("JSONデータからのスライド生成に失敗しました。デフォルトのスライドを使用します。");

          // デフォルトのスライドデータ

          const slideDataList = SlideCreator.getDefaultSlides();

          // デフォルトのスライドを追加

          slideDataList.forEach(data => {

            const slide = pptx.addSlide({ masterName: SlideCreator.MASTER_SLIDE_TITLE });

            SlideCreator.createSlideByType(slide, data, pptx, false);

          });

        }

        // Blob 取得→レンダー

        const blob = await pptx.write('blob');

        renderPreview(blob, jsonData);

        // 更新成功メッセージ

        showUpdateNotification('プレビューを更新しました');

      } else {

        alert("ページからJSONデータが見つかりませんでした。");

      }

    } catch (error) {

      console.error('[content.js] プレビュー更新エラー:', error);

      alert("プレビュー更新中にエラーが発生しました。");

    }

  };

  buttonContainer.appendChild(refreshBtn);

  

  // エクスポートボタン - アイコン化

  const dlBtn = document.createElement('button');

  dlBtn.id = 'pptx-download-btn';

  dlBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"></path></svg>';

  dlBtn.title = 'エクスポート';

  dlBtn.onclick = () => {

    if (!latestBlob) return;

    const url = URL.createObjectURL(latestBlob);

    const a = document.createElement('a');

    a.href = url;

    a.download = 'presentation.pptx';

    a.click();

    URL.revokeObjectURL(url);

  };

  buttonContainer.appendChild(dlBtn);

  

  // スライド一覧コンテナ

  const slidesContainer = document.createElement('div');

  slidesContainer.className = 'pp-slides';

  

  // プレビュー描画先

  const view = document.createElement('div');

  view.id = 'pptx-preview-view';

  slidesContainer.appendChild(view);

  panel.appendChild(slidesContainer);

  document.body.appendChild(panel);

  

  // パネルが表示されたら自動検出を開始

  startJsonAutoDetection();

  

  // 最新のJSONを保存

  lastDetectedJson = getJsonFromPage();

  

  return panel;

}

// JSONデータを使用してプレビューを更新する関数

async function updatePreviewWithJson(jsonData) {

  try {

    console.log('JSONデータを使用してプレビューを更新します');

    

    // PPTX生成

    const pptx = new PptxGenJS();

    pptx.defineLayout({ 

      name: 'myLayout', 

      width: SlideCreator.LAYOUT_WIDTH, 

      height: SlideCreator.LAYOUT_HEIGHT 

    });

    pptx.layout = 'myLayout';

    

    // マスター定義

    const logoPath = chrome.runtime.getURL('logo.png');

    SlideCreator.defineMasterSlide(pptx, logoPath);

    

    // JSONデータからスライドを生成

    const success = SlideCreator.createSlidesFromJson(pptx, jsonData, false);

    

    if (!success) {

      console.error('JSONデータからのスライド生成に失敗しました');

      showUpdateNotification('JSONデータからのスライド生成に失敗しました', 'error');

      return;

    }

    

    // Blob 取得→レンダー

    const blob = await pptx.write('blob');

    

    // 既存のプレビューパネルを取得

    const existingPanel = document.getElementById('pptx-preview-panel');

    

    // プレビューパネルが存在する場合は、そのまま更新

    if (existingPanel) {

      // 現在のスクロール位置を保存

      const slidesContainer = existingPanel.querySelector('.pp-slides');

      const scrollTop = slidesContainer ? slidesContainer.scrollTop : 0;

      

      // プレビュー画像を生成

      const previewImages = generateSlidePreviewImages(jsonData);

      

      // プレビュー画像を表示

      const view = document.getElementById('pptx-preview-view');

      if (view) {

        view.innerHTML = '';

        

        if (previewImages && previewImages.length > 0) {

          previewImages.forEach(html => {

            try {

              // スライドコンテナを作成

              const container = document.createElement('div');

              container.className = 'slide-container';

              

              // スライドをコンテナに追加

              const slideDiv = document.createElement('div');

              slideDiv.innerHTML = html;

              

              if (slideDiv.firstElementChild) {

                container.appendChild(slideDiv.firstElementChild);

                // コンテナをビューに追加

                view.appendChild(container);

              }

            } catch (slideError) {

              console.error('Error creating slide:', slideError);

            }

          });

          

          // スケルトンスクリーンを実際のコンテンツに置き換える

          setTimeout(() => {

            try {

              const realContents = document.querySelectorAll('.real-content');

              realContents.forEach(content => {

                content.classList.remove('hidden-content');

                content.classList.add('visible-content');

              });

              

              // スケルトンを非表示にする

              const skeletons = document.querySelectorAll('.skeleton');

              skeletons.forEach(skeleton => {

                skeleton.style.display = 'none';

              });

              

              // スクロール位置を復元

              if (slidesContainer) {

                slidesContainer.scrollTop = scrollTop;

              }

            } catch (animationError) {

              console.error('Error during animation transition:', animationError);

            }

          }, 1000);

        }

      }

      

      // Blobを保存

      latestBlob = blob;

      

      // 更新通知

      showUpdateNotification('新しいJSONデータを検出し、プレビューを更新しました');

    } else {

      // プレビューパネルが存在しない場合は、新しく作成

      renderPreview(blob, jsonData);

    }

  } catch (error) {

    console.error('[content.js] 自動更新エラー:', error);

    showUpdateNotification('プレビュー更新中にエラーが発生しました', 'error');

  }

}

// 更新通知を表示する関数（タイプ付き）

function showUpdateNotification(message, type = 'success') {

  // すでに通知があれば削除

  const existingNotification = document.querySelector('.update-notification');

  if (existingNotification) {

    existingNotification.remove();

  }

  

  const notification = document.createElement('div');

  notification.className = `update-notification ${type}`;

  notification.textContent = message;

  

  document.body.appendChild(notification);

  

  // 表示アニメーション

  setTimeout(() => notification.classList.add('show'), 100);

  

  // 3秒後に消える

  setTimeout(() => {

    notification.classList.remove('show');

    setTimeout(() => notification.remove(), 300);

  }, 3000);

}

// スライドデータからプレビュー画像を生成する関数

function generateSlidePreviewImages(jsonData) {

  try {

    // JSONをパース

    const data = JSON.parse(jsonData);

    const slides = Array.isArray(data) ? data : [data];

    

    // 画像配列をクリア

    slidePreviewImages = [];

    

    // 各スライドのプレビュー画像を生成

    slides.forEach((slideData, index) => {

      // slidetype または type を取得（slidetypeを優先）

      const slideType = slideData.slidetype || slideData.type || 'default';

      let previewHtml = '';

      

      // スライドタイプに応じたプレビュー画像を生成

      switch (slideType) {

        case 'default':

          previewHtml = generateDefaultSlidePreview(slideData, index);

          break;

        case 'agenda':

          previewHtml = generateAgendaSlidePreview(slideData, index);

          break;

        case 'table':

          previewHtml = generateTableSlidePreview(slideData, index);

          break;

        case 'chart':

          previewHtml = generateChartSlidePreview(slideData, index);

          break;

        case 'custom_schedule':

          previewHtml = generateScheduleSlidePreview(slideData, index);

          break;

        case 'milestone':

          previewHtml = generateMilestoneSlidePreview(slideData, index);

          break;

        default:

          previewHtml = generateDefaultSlidePreview(slideData, index);

      }

      

      slidePreviewImages.push(previewHtml);

    });

    

    return slidePreviewImages;

  } catch (e) {

    console.error('プレビュー画像生成エラー:', e);

    return [];

  }

}

// マイルストーンスライドのプレビュー画像を生成

function generateMilestoneSlidePreview(data, index) {

  const title = data.milestoneSlideTitle || '';

  const overview = data.milestoneOverview || '';

  const milestoneNames = data.milestoneNames || [];

  const milestoneDescriptions = data.milestoneDescriptions || [];

  const daysToNextMilestone = data.daysToNextMilestone || [];

  const milestoneMarkers = data.milestoneMarkers || [];

  

  // マイルストーン項目を生成

  let milestonesHtml = '';

  

  if (milestoneNames.length > 0) {

    milestonesHtml = '<div class="milestone-container">';

    

    // 縦線

    milestonesHtml += '<div class="milestone-line"></div>';

    

    // 日数

    milestonesHtml += '<div class="milestone-days">';

    daysToNextMilestone.forEach(day => {

      milestonesHtml += `<div class="milestone-day">${escapeHtml(day)}</div>`;

    });

    milestonesHtml += '</div>';

    

    // マーカー

    milestonesHtml += '<div class="milestone-markers">';

    milestoneMarkers.forEach(marker => {

      milestonesHtml += `<div class="milestone-marker">${escapeHtml(marker)}</div>`;

    });

    milestonesHtml += '</div>';

    

    // マイルストーン名と説明

    milestonesHtml += '<div class="milestone-content">';

    for (let i = 0; i < milestoneNames.length; i++) {

      const name = milestoneNames[i] || '';

      const description = i < milestoneDescriptions.length ? milestoneDescriptions[i] : '';

      

      milestonesHtml += `

        <div class="milestone-item">

          <div class="milestone-name">${escapeHtml(name)}</div>

          <div class="milestone-description">${escapeHtml(description)}</div>

        </div>

      `;

    }

    milestonesHtml += '</div>';

    

    milestonesHtml += '</div>';

  }

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-content milestone-slide">

        <!-- スケルトンスクリーン -->

        <div class="skeleton-title skeleton"></div>

        <div class="skeleton-milestone skeleton"></div>

        

        <!-- 実際のコンテンツ（最初は非表示） -->

        <div class="real-content hidden-content">

          <div class="slide-title">${escapeHtml(title)}</div>

          ${overview ? `<div class="milestone-overview">${escapeHtml(overview)}</div>` : ''}

          ${milestonesHtml}

        </div>

        

        <div class="slide-number">${index + 1}</div>

      </div>

    </div>

  `;

}

// スケジュールスライドのプレビュー画像を生成

function generateScheduleSlidePreview(data, index) {

  const title = data.scheduleTitle || '';

  const months = data.includedMonths || [];

  const weekRanges = data.weeklyWorkingDayRanges || [];

  const taskList = data.taskList || [];

  const taskCategories = Array.isArray(data.taskCategories) ? data.taskCategories : [data.taskCategories];

  

  // 月の行を生成

  let monthsHtml = '';

  if (months.length > 0) {

    monthsHtml = '<div class="schedule-months">';

    months.forEach(month => {

      monthsHtml += `<div class="month-cell">${escapeHtml(month)}</div>`;

    });

    monthsHtml += '</div>';

  }

  

  // 週の範囲行を生成

  let weeksHtml = '';

  if (weekRanges.length > 0) {

    weeksHtml = '<div class="schedule-weeks">';

    weekRanges.forEach(week => {

      weeksHtml += `<div class="week-cell">${escapeHtml(week)}</div>`;

    });

    weeksHtml += '</div>';

  }

  

  // タスクリストを生成

  let tasksHtml = '';

  if (taskList.length > 0) {

    tasksHtml = '<div class="schedule-tasks">';

    taskList.forEach(task => {

      if (Array.isArray(task) && task.length > 0) {

        tasksHtml += `<div class="task-item">${escapeHtml(task[0])}</div>`;

      }

    });

    tasksHtml += '</div>';

  }

  

  // タスクカテゴリ（ホームベース型）を生成

  let categoriesHtml = '';

  if (taskCategories.length > 0) {

    categoriesHtml = '<div class="task-categories">';

    taskCategories.forEach(category => {

      categoriesHtml += `

        <div class="task-category">

          <svg width="100" height="40" viewBox="0 0 100 40" xmlns="http://www.w3.org/2000/svg">

            <path d="M0,0 L0,40 L80,40 L100,20 L80,0 Z" fill="white" stroke="#BFBFBF" stroke-width="1"/>

            <text x="40" y="25" text-anchor="middle" font-family="Arial" font-size="12" fill="#595959" font-weight="bold">${escapeHtml(category)}</text>

          </svg>

        </div>

      `;

    });

    categoriesHtml += '</div>';

  }

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-content schedule-slide">

        <!-- スケルトンスクリーン -->

        <div class="skeleton-title skeleton"></div>

        <div class="skeleton-schedule skeleton"></div>

        

        <!-- 実際のコンテンツ（最初は非表示） -->

        <div class="real-content hidden-content">

          <div class="slide-title">${escapeHtml(title)}</div>

          <div class="schedule-container">

            ${monthsHtml}

            ${weeksHtml}

            <div class="schedule-body">

              ${tasksHtml}

              ${categoriesHtml}

            </div>

          </div>

        </div>

        

      

        <div class="slide-number">${index + 1}</div>

      </div>

    </div>

  `;

}

// デフォルトスライドのプレビュー画像を生成

function generateDefaultSlidePreview(data, index) {

  const title = data.title || '';

  const heading = data.heading || '';

  const body = Array.isArray(data.body) ? data.body.join('<br><br>') : (data.body || '');

  const items = Array.isArray(data.items) ? data.items.join('<br><br>') : (data.items || '');

  const bodyText = body || items;

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-number">${index + 1}</div>

      <div class="slide-content default-slide">

        <div class="slide-title">${escapeHtml(title)}</div>

        ${heading ? `<div class="slide-heading">${escapeHtml(heading)}</div>` : ''}

        ${bodyText ? `<div class="slide-body">${escapeHtml(bodyText)}</div>` : ''}

      </div>

    </div>

  `;

}

// アジェンダスライドのプレビュー画像を生成

function generateAgendaSlidePreview(data, index) {

  const title = data.title || '';

  const items = Array.isArray(data.body) ? data.body : (data.items || []);

  

  let itemsHtml = '';

  if (items.length > 0) {

    itemsHtml = '<ul class="agenda-items">';

    items.forEach((item, i) => {

      itemsHtml += `<li>${i + 1}. ${escapeHtml(item)}</li>`;

    });

    itemsHtml += '</ul>';

  }

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-number">${index + 1}</div>

      <div class="slide-content agenda-slide">

        <div class="slide-title">${escapeHtml(title)}</div>

        ${itemsHtml}

      </div>

    </div>

  `;

}

// テーブルスライドのプレビュー画像を生成

function generateTableSlidePreview(data, index) {

  const title = data.title || '';

  const heading = data.heading || '';

  const tableData = data.tableData || [];

  

  let tableHtml = '';

  if (tableData.length > 0) {

    tableHtml = '<table class="preview-table">';

    

    // ヘッダー行

    tableHtml += '<tr class="table-header">';

    if (tableData[0] && Array.isArray(tableData[0])) {

      tableData[0].forEach(cell => {

        tableHtml += `<th>${escapeHtml(cell)}</th>`;

      });

    }

    tableHtml += '</tr>';

    

    // データ行

    for (let i = 1; i < tableData.length; i++) {

      tableHtml += '<tr>';

      if (Array.isArray(tableData[i])) {

        tableData[i].forEach(cell => {

          tableHtml += `<td>${escapeHtml(cell)}</td>`;

        });

      }

      tableHtml += '</tr>';

    }

    

    tableHtml += '</table>';

  }

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-number">${index + 1}</div>

      <div class="slide-content table-slide">

        <div class="slide-title">${escapeHtml(title)}</div>

        ${heading ? `<div class="slide-heading">${escapeHtml(heading)}</div>` : ''}

        <div class="table-container">

          ${tableHtml}

        </div>

      </div>

    </div>

  `;

}

// チャートスライドのプレビュー画像を生成

function generateChartSlidePreview(data, index) {

  const title = data.title || '';

  const heading = data.heading || '';

  const chartTitle = data.chartTitle || '';

  const chartType = data.chartType || 'bar';

  const chartData = data.chartData || [];

  

  // チャートのSVG表現を生成

  let chartSvg = generateChartSvg(chartType, chartData, {

    title: chartTitle,

    showLegend: data.showLegend

  });

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-content chart-slide">

        <!-- スケルトンスクリーン -->

        <div class="skeleton-title skeleton"></div>

        ${heading ? `<div class="skeleton-heading skeleton"></div>` : ''}

        <div class="skeleton-chart skeleton"></div>

        

        <!-- 実際のコンテンツ（最初は非表示） -->

        <div class="real-content hidden-content">

          <div class="slide-title">${escapeHtml(title)}</div>

          ${heading ? `<div class="slide-heading">${escapeHtml(heading)}</div>` : ''}

          <div class="chart-container">

            ${chartSvg}

          </div>

        </div>

        

        <div class="slide-number">${index + 1}</div>

      </div>

    </div>

  `;

}

// チャートデータからSVG画像を生成する関数

function generateChartSvg(chartType, chartData, options = {}) {

  const width = 870;

  const height = 350;

  const padding = 40;

  const chartTitle = options.title || '';

  const showLegend = options.showLegend || false;

  

  // 基本的なSVG構造

  let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;

  svg += `<rect width="${width}" height="${height}" fill="#ffffff" rx="5" ry="5"/>`;

  

  // チャートタイトル

  if (chartTitle) {

    svg += `<text x="${width/2}" y="25" text-anchor="middle" font-family="Arial" font-size="16" font-weight="bold">${escapeHtml(chartTitle)}</text>`;

  }

  

  // チャートの種類に応じた描画

  if (chartType === 'bar') {

    svg += generateBarChartSvg(chartData, width, height, padding, showLegend);

  } else if (chartType === 'line') {

    svg += generateLineChartSvg(chartData, width, height, padding, showLegend);

  } else if (chartType === 'doughnut' || chartType === 'pie') {

    svg += generatePieChartSvg(chartData, width, height, padding, showLegend, chartType === 'doughnut');

  }

  

  svg += '</svg>';

  return svg;

}

// 棒グラフのSVG生成

function generateBarChartSvg(chartData, width, height, padding, showLegend) {

  if (!chartData || chartData.length === 0) return '';

  

  const chartWidth = width - padding * 2;

  const chartHeight = height - padding * 2 - (showLegend ? 40 : 0);

  const startY = padding + 30; // タイトル用の余白

  

  // すべてのデータセットからラベルと最大値を取得

  const allLabels = chartData[0].labels || [];

  let maxValue = 0;

  

  chartData.forEach(dataset => {

    const values = dataset.values || [];

    const datasetMax = Math.max(...values);

    if (datasetMax > maxValue) maxValue = datasetMax;

  });

  

  // スケーリング係数

  const yScale = chartHeight / (maxValue * 1.1);

  const barWidth = chartWidth / (allLabels.length * chartData.length + chartData.length);

  const groupWidth = barWidth * chartData.length;

  

  // 色の配列

  const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8E24AA', '#16A2D7', '#FB8C00'];

  

  let svg = '';

  

  // X軸

  svg += `<line x1="${padding}" y1="${startY + chartHeight}" x2="${width - padding}" y2="${startY + chartHeight}" stroke="#666" stroke-width="1"/>`;

  

  // Y軸

  svg += `<line x1="${padding}" y1="${startY}" x2="${padding}" y2="${startY + chartHeight}" stroke="#666" stroke-width="1"/>`;

  

  // X軸ラベル

  allLabels.forEach((label, i) => {

    const x = padding + (i * (groupWidth + barWidth)) + groupWidth / 2;

    svg += `<text x="${x}" y="${startY + chartHeight + 20}" text-anchor="middle" font-family="Arial" font-size="12">${escapeHtml(label)}</text>`;

  });

  

  // Y軸ラベル（5分割）

  for (let i = 0; i <= 5; i++) {

    const value = Math.round(maxValue * i / 5);

    const y = startY + chartHeight - (value * yScale);

    svg += `<text x="${padding - 10}" y="${y + 5}" text-anchor="end" font-family="Arial" font-size="12">${value}</text>`;

    svg += `<line x1="${padding}" y1="${y}" x2="${width - padding}" y2="${y}" stroke="#ddd" stroke-width="1" stroke-dasharray="5,5"/>`;

  }

  

  // 棒グラフの描画

  chartData.forEach((dataset, datasetIndex) => {

    const values = dataset.values || [];

    const color = colors[datasetIndex % colors.length];

    

    values.forEach((value, i) => {

      const barHeight = value * yScale;

      const x = padding + (i * (groupWidth + barWidth)) + (datasetIndex * barWidth);

      const y = startY + chartHeight - barHeight;

      

      svg += `<rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${color}" stroke="#fff" stroke-width="1">`;

      svg += `<title>${dataset.name}: ${value}</title>`;

      svg += `</rect>`;

      

      // 値ラベル

      svg += `<text x="${x + barWidth/2}" y="${y - 5}" text-anchor="middle" font-family="Arial" font-size="11">${value}</text>`;

    });

  });

  

  // 凡例

  if (showLegend) {

    const legendY = height - 25;

    const legendItemWidth = width / chartData.length;

    

    chartData.forEach((dataset, i) => {

      const x = padding + (i * legendItemWidth);

      const color = colors[i % colors.length];

      

      svg += `<rect x="${x}" y="${legendY}" width="10" height="10" fill="${color}"/>`;

      svg += `<text x="${x + 15}" y="${legendY + 9}" font-family="Arial" font-size="12">${escapeHtml(dataset.name)}</text>`;

    });

  }

  

  return svg;

}

// 折れ線グラフのSVG生成

function generateLineChartSvg(chartData, width, height, padding, showLegend) {

  if (!chartData || chartData.length === 0) return '';

  

  const chartWidth = width - padding * 2;

  const chartHeight = height - padding * 2 - (showLegend ? 40 : 0);

  const startY = padding + 30; // タイトル用の余白

  

  // すべてのデータセットからラベルと最大値を取得

  const allLabels = chartData[0].labels || [];

  let maxValue = 0;

  

  chartData.forEach(dataset => {

    const values = dataset.values || [];

    const datasetMax = Math.max(...values);

    if (datasetMax > maxValue) maxValue = datasetMax;

  });

  

  // スケーリング係数

  const yScale = chartHeight / (maxValue * 1.1);

  const xScale = chartWidth / (allLabels.length - 1 || 1);

  

  // 色の配列

  const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8E24AA', '#16A2D7', '#FB8C00'];

  

  let svg = '';

  

  // X軸

  svg += `<line x1="${padding}" y1="${startY + chartHeight}" x2="${width - padding}" y2="${startY + chartHeight}" stroke="#666" stroke-width="1"/>`;

  

  // Y軸

  svg += `<line x1="${padding}" y1="${startY}" x2="${padding}" y2="${startY + chartHeight}" stroke="#666" stroke-width="1"/>`;

  

  // X軸ラベル

  allLabels.forEach((label, i) => {

    const x = padding + (i * xScale);

    svg += `<text x="${x}" y="${startY + chartHeight + 20}" text-anchor="middle" font-family="Arial" font-size="12">${escapeHtml(label)}</text>`;

  });

  

  // Y軸ラベル（5分割）

  for (let i = 0; i <= 5; i++) {

    const value = Math.round(maxValue * i / 5);

    const y = startY + chartHeight - (value * yScale);

    svg += `<text x="${padding - 10}" y="${y + 5}" text-anchor="end" font-family="Arial" font-size="12">${value}</text>`;

    svg += `<line x1="${padding}" y1="${y}" x2="${width - padding}" y2="${y}" stroke="#ddd" stroke-width="1" stroke-dasharray="5,5"/>`;

  }

  

  // 折れ線グラフの描画

  chartData.forEach((dataset, datasetIndex) => {

    const values = dataset.values || [];

    const color = colors[datasetIndex % colors.length];

    

    // 線を描画

    let pathData = '';

    values.forEach((value, i) => {

      const x = padding + (i * xScale);

      const y = startY + chartHeight - (value * yScale);

      

      if (i === 0) {

        pathData += `M ${x} ${y}`;

      } else {

        pathData += ` L ${x} ${y}`;

      }

    });

    

    svg += `<path d="${pathData}" fill="none" stroke="${color}" stroke-width="2"/>`;

    

    // データポイントを描画

    values.forEach((value, i) => {

      const x = padding + (i * xScale);

      const y = startY + chartHeight - (value * yScale);

      

      svg += `<circle cx="${x}" cy="${y}" r="4" fill="${color}" stroke="#fff" stroke-width="1">`;

      svg += `<title>${dataset.name}: ${value}</title>`;

      svg += `</circle>`;

      

      // 値ラベル

      svg += `<text x="${x}" y="${y - 10}" text-anchor="middle" font-family="Arial" font-size="11">${value}</text>`;

    });

  });

  

  // 凡例

  if (showLegend) {

    const legendY = height - 25;

    const legendItemWidth = width / chartData.length;

    

    chartData.forEach((dataset, i) => {

      const x = padding + (i * legendItemWidth);

      const color = colors[i % colors.length];

      

      svg += `<line x1="${x}" y1="${legendY + 5}" x2="${x + 10}" y2="${legendY + 5}" stroke="${color}" stroke-width="2"/>`;

      svg += `<text x="${x + 15}" y="${legendY + 9}" font-family="Arial" font-size="12">${escapeHtml(dataset.name)}</text>`;

    });

  }

  

  return svg;

}

// 円グラフ/ドーナツグラフのSVG生成

function generatePieChartSvg(chartData, width, height, padding, showLegend, isDoughnut) {

  if (!chartData || chartData.length === 0 || !chartData[0].values) return '';

  

  const dataset = chartData[0]; // 円グラフは最初のデータセットのみ使用

  const values = dataset.values || [];

  const labels = dataset.labels || [];

  

  const centerX = width / 2;

  const centerY = height / 2 - 10;

  const radius = Math.min(width, height) / 2 - padding - 20;

  const innerRadius = isDoughnut ? radius * 0.6 : 0;

  

  // 色の配列

  const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8E24AA', '#16A2D7', '#FB8C00', '#F06292', '#00ACC1', '#AB47BC'];

  

  // 合計値を計算

  const total = values.reduce((sum, value) => sum + value, 0);

  

  let svg = '';

  

  // 円グラフの描画

  let startAngle = 0;

  values.forEach((value, i) => {

    const percentage = value / total;

    const endAngle = startAngle + percentage * Math.PI * 2;

    

    // 円弧のパスを計算

    const x1 = centerX + radius * Math.cos(startAngle);

    const y1 = centerY + radius * Math.sin(startAngle);

    const x2 = centerX + radius * Math.cos(endAngle);

    const y2 = centerY + radius * Math.sin(endAngle);

    

    const largeArcFlag = percentage > 0.5 ? 1 : 0;

    

    // 外側の円弧

    let pathData = `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;

    

    // ドーナツグラフの場合は内側の円弧も描画

    if (isDoughnut) {

      const ix1 = centerX + innerRadius * Math.cos(startAngle);

      const iy1 = centerY + innerRadius * Math.sin(startAngle);

      const ix2 = centerX + innerRadius * Math.cos(endAngle);

      const iy2 = centerY + innerRadius * Math.sin(endAngle);

      

      pathData = `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} ` +

                 `L ${ix2} ${iy2} A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${ix1} ${iy1} Z`;

    }

    

    const color = colors[i % colors.length];

    

    svg += `<path d="${pathData}" fill="${color}" stroke="#fff" stroke-width="1">`;

    svg += `<title>${labels[i] || ''}: ${value} (${Math.round(percentage * 100)}%)</title>`;

    svg += `</path>`;

    

    // ラベルの位置を計算（セグメントの中央）

    const midAngle = startAngle + (endAngle - startAngle) / 2;

    const labelRadius = radius * 0.7;

    const labelX = centerX + labelRadius * Math.cos(midAngle);

    const labelY = centerY + labelRadius * Math.sin(midAngle);

    

    // パーセント表示

    if (percentage > 0.05) { // 小さすぎるセグメントにはラベルを表示しない

      svg += `<text x="${labelX}" y="${labelY}" text-anchor="middle" font-family="Arial" font-size="12" fill="#fff" font-weight="bold">`;

      svg += `${Math.round(percentage * 100)}%`;

      svg += `</text>`;

    }

    

    startAngle = endAngle;

  });

  

  // 凡例

  if (showLegend) {

    const legendY = height - 30;

    const legendItemWidth = width / Math.min(values.length, 4);

    const legendItemsPerRow = Math.min(values.length, 4);

    

    values.forEach((value, i) => {

      const row = Math.floor(i / legendItemsPerRow);

      const col = i % legendItemsPerRow;

      const x = padding + (col * legendItemWidth);

      const y = legendY - (row * 20);

      const color = colors[i % colors.length];

      const percentage = value / total;

      

      svg += `<rect x="${x}" y="${y}" width="10" height="10" fill="${color}"/>`;

      svg += `<text x="${x + 15}" y="${y + 9}" font-family="Arial" font-size="11">`;

      svg += `${escapeHtml(labels[i] || '')}: ${value} (${Math.round(percentage * 100)}%)`;

      svg += `</text>`;

    });

  }

  

  return svg;

}

// HTMLエスケープ関数

function escapeHtml(text) {

  if (!text) return '';

  return text

    .toString()

    .replace(/&/g, '&amp;')

    .replace(/</g, '&lt;')

    .replace(/>/g, '&gt;')

    .replace(/"/g, '&quot;')

    .replace(/'/g, '&#039;');

}

/* スライドプレビューのスタイルを注入 */

function injectPreviewStyles() {

  const styleEl = document.createElement('style');

  styleEl.textContent = `

/* プレビューパネル全体のスタイル */

#pptx-preview-panel {

  position: fixed;

  top: 0;

  right: 0;

  width: 30%; /* 全幅を使用 */

  height: 100vh;

  background: #f5f5f5; /* 背景色をライトグレーに変更 */

  box-shadow: -2px 0 10px rgba(0,0,0,0.2);

  z-index: 9999;

  display: flex;

  flex-direction: column;

  overflow: hidden;

}

.pp-header {

  display: flex;

  align-items: center;

  padding: 10px 15px;

  background: #e0e0e0; /* ヘッダーの背景色を少し濃いグレーに */

  border-bottom: 1px solid #ccc;

}

.pp-header h3 {

  margin: 0;

  flex-grow: 1;

  font-size: 16px;

  color: #333; /* テキスト色を少し暗く */

}

.pp-header button {

  background: none;

  border: none;

  cursor: pointer;

  font-size: 16px;

  margin-left: 10px;

}

.pp-button-container {

  display: flex;

  gap: 10px;

}

/* スライド一覧エリア */

.pp-slides {

  flex-grow: 1;

  overflow-y: auto;

  padding: 15px;

  display: flex;

  flex-direction: column;

  align-items: center; /* スライドを中央に配置 */

  background: #e8e8e8; /* スライド一覧エリアの背景色をグレーに */

}

/* スライドコンテナ */

.slide-container {

  width: 384px;  /* 1280px × 0.3 = 384px */

  height: 216px; /* 720px × 0.3 = 216px */

  margin-bottom: 20px; /* スライド間の隙間を広げる */

  position: relative;

  overflow: hidden;

  box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* シャドウを強調 */

  border-radius: 5px;

  background: #d0d0d0; /* コンテナ背景をグレーに */

  padding: 10px; /* パディングを追加 */

}

/* スライド基本レイアウト */

.slide-preview {

  background: white;

  border: 1px solid #ccc;

  border-radius: 3px;

  box-shadow: 0 2px 5px rgba(0,0,0,0.1);

  position: absolute; /* 重要: absoluteに変更 */

  top: 10px; /* パディングに合わせて調整 */

  left: 10px; /* パディングに合わせて調整 */

  width: 1280px;

  height: 720px;

  transform-origin: top left; /* 重要: top leftに変更 */

  transform: scale(0.28); /* スケールを少し小さく */

  margin-bottom: 0; /* 重要: マージンを削除 */

  overflow: hidden;

}

/* 更新通知のスタイル */

.update-notification {

  position: fixed;

  bottom: 25px;

  right: 25px;

  padding: 12px 18px;

  border-radius: 5px;

  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.2);

  z-index: 9999;

  font-size: 16px;

  transform: translateY(100px);

  opacity: 0;

  transition: transform 0.3s ease, opacity 0.3s ease;

}

.update-notification.show {

  transform: translateY(0);

  opacity: 1;

}

.update-notification.success {

  background: rgba(16, 124, 16, 0.9);

  color: white;

}

.update-notification.error {

  background: rgba(232, 17, 35, 0.9);

  color: white;

}

.pp-slides {

  flex-grow: 1;

  overflow-y: auto;

  padding: 15px;

  display: flex;

  flex-direction: column;

  align-items: center; /* スライドを中央に配置 */

}

/* ページを左に詰める - 無効化 */

body.pptx-preview-active {

  margin-right: 30%; /* 右側30%を空ける */

  overflow: hidden; /* 本文のスクロールを防止 */

  transition: margin-right 0.3s ease;

}

/* スライドコンテナ */

.slide-container {

  width: 384px;  /* 1280px × 0.3 = 384px */

  height: 216px; /* 720px × 0.3 = 216px */

  margin-bottom: 10px; /* スライド間の隙間を適切に設定 */

  position: relative;

  overflow: hidden;

}

/* スライド基本レイアウト */

.slide-preview {

  background: white;

  border: 1px solid #ddd;

  border-radius: 5px;

  box-shadow: 0 2px 5px rgba(0,0,0,0.1);

  position: absolute; /* 重要: absoluteに変更 */

  top: 0;

  left: 0;

  width: 1280px;

  height: 720px;

  transform-origin: top left; /* 重要: top leftに変更 */

  transform: scale(0.3);

  margin-bottom: 0; /* 重要: マージンを削除 */

  overflow: hidden;

}

.slide-content {

  position: absolute;

  top: 0;

  left: 0;

  width: 100%;

  height: 100%;

  padding: 40px;

  box-sizing: border-box;

}

/* スライド共通要素 */

.slide-number {

  position: absolute;

  bottom: 20px;

  right: 30px;

  color: #000000;

  font-size: 24px;

  font-weight: bold;

  z-index: 10;

}

/* スライドテキスト要素 */

.slide-title {

  font-size: 60px;

  font-weight: bold;

  margin-bottom: 35px;

  color: #333;

  width: 90%;

}

.slide-heading {

  font-size: 48px;

  background: #DDDDDD;

  padding: 18px;

  margin-bottom: 35px;

  border-radius: 6px;

  color: #000000;

  width: 90%;

  box-sizing: border-box;

  display: inline-block;

}

.slide-body {

  font-size: 36px;

  line-height: 1.5;

  color: #555;

  width: 90%;

}

/* アジェンダスタイル */

.agenda-items {

  list-style-type: none;

  padding: 0;

  margin-top: 30px;

  width: 90%;

}

.agenda-items li {

  font-size: 24px;

  margin-bottom: 5px;

  color: #333;

  padding-left: 18px;

}

/* テーブルスタイル */

.table-container {

  overflow-x: auto;

  margin-top: 18px;

  width: 90%;

}

.preview-table {

  width: 100%;

  border-collapse: collapse;

  margin-top: 18px;

  font-size: 24px;

}

.preview-table th {

  background: #404040;

  color: white;

  padding: 18px;

  text-align: center;

  font-weight: bold;

  font-size: 24px;

}

.preview-table td {

  padding: 18px;

  border: 2px solid #BFBFBF;

  text-align: center;

  font-size: 24px;

}

/* チャートスタイル */

.chart-container {

  display: flex;

  justify-content: center;

  align-items: center;

  margin-top: 35px;

  overflow: hidden;

  height: 70%;

  width: 90%;

}

.chart-container svg {

  max-width: 100%;

  height: auto;

}

/* スケルトンローディングスタイル */

.skeleton {

  background: rgb(215, 215, 215);

  position: relative;

  overflow: hidden;

}

.skeleton::after {

  content: "";

  position: absolute;

  top: 0;

  right: 0;

  bottom: 0;

  left: 0;

  transform: translateX(-100%);

  background-image: linear-gradient(

    90deg,

    rgba(255, 255, 255, 0) 0,

    rgba(255, 255, 255, 0.2) 20%,

    rgba(255, 255, 255, 0.5) 60%,

    rgba(255, 255, 255, 0)

  );

  animation: shimmer 2s infinite;

}

@keyframes shimmer {

  100% {

    transform: translateX(100%);

  }

}

/* スケルトン要素バリエーション */

.skeleton-text {

  height: 36px;

  margin-bottom: 20px;

  border-radius: 6px;

  width: 90%;

}

.skeleton-title {

  height: 60px;

  width: 70%;

  margin-bottom: 35px;

  border-radius: 6px;

}

.skeleton-heading {

  height: 48px;

  width: 90%;

  margin-bottom: 35px;

  border-radius: 6px;

}

.skeleton-body {

  height: 200px;

  border-radius: 6px;

  width: 90%;

}

.skeleton-agenda-item {

  height: 42px;

  margin-bottom: 30px;

  border-radius: 6px;

  width: 90%;

}

.skeleton-table {

  height: 350px;

  border-radius: 6px;

  width: 90%;

}

.skeleton-chart {

  height: 350px;

  border-radius: 6px;

  width: 90%;

}

/* コンテンツ表示制御 */

.hidden-content {

  opacity: 0;

  transition: opacity 0.3s ease;

}

.visible-content {

  opacity: 1;

  transition: opacity 0.3s ease;

}

/* スケジュールスライド用のスタイル */

.schedule-container {

  width: 90%;

  margin-top: 70px;

}

.schedule-months {

  display: flex;

  background-color: #787878;

  color: white;

  font-weight: bold;

  margin-bottom: 4px;

  font-size: 32px;

}

.month-cell {

  flex: 1;

  text-align: center;

  padding: 14px 8px;

  border: 2px solid white;

}

.schedule-weeks {

  display: flex;

  background-color: #262626;

  color: white;

  font-size: 18px;

  margin-bottom: 18px;

}

.week-cell {

  flex: 1;

  text-align: center;

  padding: 8px 4px;

  border: 2px solid white;

}

.schedule-body {

  display: flex;

}

.schedule-tasks {

  width: 220px;

  background-color: #F2F2F2;

  margin-right: 20px;

}

.task-item {

  padding: 14px;

  border-bottom: 2px solid white;

  font-size: 28px;

  color: rgb(0, 0, 0);

}

.task-categories {

  display: flex;

  flex-direction: column;

  gap: 20px;

  width: calc(100% - 240px);

}

.task-category {

  margin-bottom: 12px;

}

.task-category svg {

  width: 220px;

  height: 88px;

}

.skeleton-schedule {

  height: 350px;

  width: 90%;

  border-radius: 6px;

}

/* マイルストーンスライド用のスタイル */

.milestone-container {

  display: flex;

  position: relative;

  margin-top: 35px;

  padding-left: 35px;

  min-height: 200px;

  width: 90%;

}

.milestone-line {

  position: absolute;

  left: 185px;

  top: 0;

  bottom: 0;

  width: 3px;

  background-color: #C00000;

}

.milestone-days {

  width: 100px;

  margin-right: 25px;

  text-align: right;

}

.milestone-day {

  font-size: 20px;

  font-weight: bold;

  color: #595959;

  margin-bottom: 40px;

  padding-top: 12px;

}

.milestone-markers {

  width: 50px;

  margin-right: 25px;

  text-align: center;

  position: relative;

  z-index: 2;

}

.milestone-marker {

  font-size: 34px;

  font-weight: bold;

  color: #C00000;

  margin-bottom: 40px;

}

.milestone-content {

  flex: 1;

  max-width: calc(100% - 200px);

}

.milestone-item {

  margin-bottom: 30px;

}

.milestone-name {

  font-size: 24px;

  font-weight: bold;

  color: #C00000;

  margin-bottom: 12px;

}

.milestone-description {

  font-size: 20px;

  color: #595959;

  line-height: 1.4;

}

.milestone-overview {

  font-size: 24px;

  font-weight: bold;

  color: #C00000;

  margin-bottom: 20px;

  width: 90%;

}

.skeleton-milestone {

  height: 400px;

  width: 90%;

  border-radius: 6px;

}

/* JSON検出通知のスタイル */

.json-detected {

  position: fixed;

  bottom: 25px;

  right: 25px;

  background: rgba(0, 120, 212, 0.9);

  color: white;

  padding: 12px 18px;

  border-radius: 5px;

  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.2);

  z-index: 9999;

  font-size: 16px;

  transform: translateY(100px);

  opacity: 0;

  transition: transform 0.3s ease, opacity 0.3s ease;

}

.json-detected.show {

  transform: translateY(0);

  opacity: 1;

}

/* アイコンボタンのスタイル */

#pptx-refresh-btn, #pptx-download-btn {

  background: none;

  color: #333;

  padding: 8px;

  border-radius: 50%;

  font-size: 14px;

  width: 32px;

  height: 32px;

  display: flex;

  align-items: center;

  justify-content: center;

  transition: background-color 0.2s ease;

}

#pptx-download-btn {

  background: #0078d4;

  color: white;

}

#pptx-refresh-btn {

  background: #107C10;

  color: white;

}

#pptx-download-btn:hover {

  background: #106ebe;

}

#pptx-refresh-btn:hover {

  background: #0B5C0B;

}

/* 自動更新ボタンのスタイル - 元のまま */

#pptx-auto-update-btn {

  background: #0078d4;

  color: white;

  padding: 5px 10px;

  border-radius: 3px;

  font-size: 14px;

}

.auto-update-on {

  background: #107C10 !important;

}

.auto-update-off {

  background: #d83b01 !important;

}

#pptx-auto-update-btn:hover {

  opacity: 0.9;

}

.pp-close-btn {

  background: none;

  border: none;

  color: #333;

  font-size: 20px;

  cursor: pointer;

  width: 32px;

  height: 32px;

  display: flex;

  align-items: center;

  justify-content: center;

  border-radius: 50%;

  transition: background-color 0.2s ease;

}

.pp-close-btn:hover {

  background: rgba(0, 0, 0, 0.1);

}

`;

  document.head.appendChild(styleEl);

}

// デフォルトスライドのプレビュー画像を生成

function generateDefaultSlidePreview(data, index) {

  const title = data.title || '';

  const heading = data.heading || '';

  const body = Array.isArray(data.body) ? data.body.join('<br><br>') : (data.body || '');

  const items = Array.isArray(data.items) ? data.items.join('<br><br>') : (data.items || '');

  const bodyText = body || items;

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-content default-slide">

        <!-- スケルトンスクリーン -->

        <div class="skeleton-title skeleton"></div>

        ${heading ? `<div class="skeleton-heading skeleton"></div>` : ''}

        ${bodyText ? `<div class="skeleton-body skeleton"></div>` : ''}

        

        <!-- 実際のコンテンツ（最初は非表示） -->

        <div class="real-content hidden-content">

          <div class="slide-title">${escapeHtml(title)}</div>

          ${heading ? `<div class="slide-heading">${escapeHtml(heading)}</div>` : ''}

          ${bodyText ? `<div class="slide-body">${escapeHtml(bodyText)}</div>` : ''}

        </div>

        

  

        <div class="slide-number">${index + 1}</div>

      </div>

    </div>

  `;

}

// アジェンダスライドのプレビュー画像を生成

function generateAgendaSlidePreview(data, index) {

  const title = data.title || '';

  const items = Array.isArray(data.body) ? data.body : (data.items || []);

  

  let itemsHtml = '';

  let skeletonItemsHtml = '';

  

  if (items.length > 0) {

    itemsHtml = '<ul class="agenda-items">';

    items.forEach((item, i) => {

      itemsHtml += `<li>${i + 1}. ${escapeHtml(item)}</li>`;

    });

    itemsHtml += '</ul>';

    

    // スケルトンアジェンダ項目

    skeletonItemsHtml = '';

    items.forEach(() => {

      skeletonItemsHtml += `<div class="skeleton-agenda-item skeleton"></div>`;

    });

  }

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-content agenda-slide">

        <!-- スケルトンスクリーン -->

        <div class="skeleton-title skeleton"></div>

        ${skeletonItemsHtml}

        

        <!-- 実際のコンテンツ（最初は非表示） -->

        <div class="real-content hidden-content">

          <div class="slide-title">${escapeHtml(title)}</div>

          ${itemsHtml}

        </div>

        

        <div class="slide-number">${index + 1}</div>

      </div>

    </div>

  `;

}

// テーブルスライドのプレビュー画像を生成

function generateTableSlidePreview(data, index) {

  const title = data.title || '';

  const heading = data.heading || '';

  const tableData = data.tableData || [];

  

  let tableHtml = '';

  if (tableData.length > 0) {

    tableHtml = '<table class="preview-table">';

    

    // ヘッダー行

    tableHtml += '<tr class="table-header">';

    if (tableData[0] && Array.isArray(tableData[0])) {

      tableData[0].forEach(cell => {

        tableHtml += `<th>${escapeHtml(cell)}</th>`;

      });

    }

    tableHtml += '</tr>';

    

    // データ行

    for (let i = 1; i < tableData.length; i++) {

      tableHtml += '<tr>';

      if (Array.isArray(tableData[i])) {

        tableData[i].forEach(cell => {

          tableHtml += `<td>${escapeHtml(cell)}</td>`;

        });

      }

      tableHtml += '</tr>';

    }

    

    tableHtml += '</table>';

  }

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-content table-slide">

        <!-- スケルトンスクリーン -->

        <div class="skeleton-title skeleton"></div>

        ${heading ? `<div class="skeleton-heading skeleton"></div>` : ''}

        <div class="skeleton-table skeleton"></div>

        

        <!-- 実際のコンテンツ（最初は非表示） -->

        <div class="real-content hidden-content">

          <div class="slide-title">${escapeHtml(title)}</div>

          ${heading ? `<div class="slide-heading">${escapeHtml(heading)}</div>` : ''}

          <div class="table-container">

            ${tableHtml}

          </div>

        </div>

        

      

        <div class="slide-number">${index + 1}</div>

      </div>

    </div>

  `;

}

// チャートスライドのプレビュー画像を生成

function generateChartSlidePreview(data, index) {

  const title = data.title || '';

  const heading = data.heading || '';

  const chartTitle = data.chartTitle || '';

  const chartType = data.chartType || 'bar';

  const chartData = data.chartData || [];

  

  // チャートのSVG表現を生成

  let chartSvg = generateChartSvg(chartType, chartData, {

    title: chartTitle,

    showLegend: data.showLegend

  });

  

  return `

    <div class="slide-preview" data-index="${index}">

      <div class="slide-content chart-slide">

        <!-- スケルトンスクリーン -->

        <div class="skeleton-title skeleton"></div>

        ${heading ? `<div class="skeleton-heading skeleton"></div>` : ''}

        <div class="skeleton-chart skeleton"></div>

        

        <!-- 実際のコンテンツ（最初は非表示） -->

        <div class="real-content hidden-content">

          <div class="slide-title">${escapeHtml(title)}</div>

          ${heading ? `<div class="slide-heading">${escapeHtml(heading)}</div>` : ''}

          <div class="chart-container">

            ${chartSvg}

          </div>

        </div>

        

        <div class="slide-number">${index + 1}</div>

      </div>

    </div>

  `;

}

// Blob を受け取ってプレビューをレンダー

function renderPreview(blob, jsonData) {

  console.log('renderPreview called with blob size:', blob.size);

  latestBlob = blob;

  

  try {

    // createPreviewPanel が定義されていることを確認

    if (typeof createPreviewPanel !== 'function') {

      console.error('createPreviewPanel is not defined. Reloading content script...');

      // 必要な関数が定義されていない場合は、エラーメッセージを表示

      alert("プレビュー表示に必要な機能が読み込まれていません。ページをリロードしてから再試行してください。");

      return;

    }

    

    const panel = createPreviewPanel();

    

    // スタイルを注入

    if (typeof injectPreviewStyles === 'function') {

      injectPreviewStyles();

    } else {

      console.warn('injectPreviewStyles is not defined, skipping style injection');

    }

    

    // プレビュー画像を生成

    if (typeof generateSlidePreviewImages !== 'function') {

      console.error('generateSlidePreviewImages is not defined');

      alert("プレビュー画像生成機能が読み込まれていません。ページをリロードしてから再試行してください。");

      return;

    }

    

    const previewImages = generateSlidePreviewImages(jsonData);

    

    // プレビュー画像を表示

    const view = document.getElementById('pptx-preview-view');

    if (!view) {

      console.error('pptx-preview-view element not found');

      alert("プレビュー表示領域が見つかりません。ページをリロードしてから再試行してください。");

      return;

    }

    

    view.innerHTML = '';

    

    if (previewImages && previewImages.length > 0) {

      previewImages.forEach(html => {

        try {

          // スライドコンテナを作成

          const container = document.createElement('div');

          container.className = 'slide-container';

          

          // スライドをコンテナに追加

          const slideDiv = document.createElement('div');

          slideDiv.innerHTML = html;

          

          if (slideDiv.firstElementChild) {

            container.appendChild(slideDiv.firstElementChild);

            // コンテナをビューに追加

            view.appendChild(container);

          } else {

            console.warn('No slide content found in HTML:', html);

          }

        } catch (slideError) {

          console.error('Error creating slide:', slideError);

        }

      });

      

      // 1秒後にスケルトンスクリーンを実際のコンテンツに置き換える

      setTimeout(() => {

        try {

          const realContents = document.querySelectorAll('.real-content');

          realContents.forEach(content => {

            content.classList.remove('hidden-content');

            content.classList.add('visible-content');

          });

          

          // スケルトンを非表示にする

          const skeletons = document.querySelectorAll('.skeleton');

          skeletons.forEach(skeleton => {

            skeleton.style.display = 'none';

          });

        } catch (animationError) {

          console.error('Error during animation transition:', animationError);

        }

      }, 1000);

    } else {

      // プレビュー画像がない場合は代替メッセージを表示

      const message = document.createElement('div');

      message.style.padding = '20px';

      message.style.textAlign = 'center';

      message.innerHTML = `

        <p style="margin-bottom: 20px; color: #666;">プレゼンテーションが生成されました。エクスポートボタンからファイルを保存できます。</p>

        <svg width="200" height="150" viewBox="0 0 200 150" xmlns="http://www.w3.org/2000/svg" style="margin-bottom: 20px;">

          <rect x="10" y="10" width="180" height="130" fill="#f5f5f5" stroke="#ccc" stroke-width="1"/>

          <text x="100" y="60" font-family="Arial" font-size="14" text-anchor="middle">プレゼンテーションが生成されました</text>

          <text x="100" y="85" font-family="Arial" font-size="12" text-anchor="middle">エクスポートボタンからファイルを保存できます</text>

          <path d="M70,110 L130,110 L100,130 Z" fill="#0078d4"/>

        </svg>

      `;

      view.appendChild(message);

    }

  } catch (error) {

    console.error('プレビューレンダリングエラー:', error);

    alert("プレビュー表示中にエラーが発生しました。ページをリロードしてから再試行してください。");

  }

}

 

// JSONデータにグラフが含まれているか検出する関数

function containsChartData(jsonData) {

  try {

    const data = JSON.parse(jsonData);

    const slides = Array.isArray(data) ? data : [data];

    

    // いずれかのスライドがチャートタイプかどうかをチェック

    return slides.some(slide => 

      slide.slidetype === 'chart' || 

      slide.type === 'chart' || 

      (slide.chartData && Array.isArray(slide.chartData))

    );

  } catch (e) {

    console.error('JSONデータの解析エラー:', e);

    return false;

  }

}

 // ===== JSON検出関連の関数 =====

 // ページ内のJSONを検出して通知

function detectJsonInPage() {

  // プレビューパネルが表示されていない場合は何もしない

  const previewPanel = document.getElementById('pptx-preview-panel');

  if (!previewPanel) {

    return false;

  }

  

  // ページ内のすべてのJSONコードブロックを探す

  const codeBlocks = document.querySelectorAll('code.language-json, pre');

  

  // 有効なJSONを含むブロックを収集

  const validJsonBlocks = [];

  for (const block of codeBlocks) {

    try {

      const text = block.innerText || block.textContent;

      // JSONとして解析できるか確認

      JSON.parse(text);

      validJsonBlocks.push(block);

    } catch (e) {

      // JSONとして解析できない場合はスキップ

      continue;

    }

  }

  

  if (validJsonBlocks.length === 0) {

    return false; // 有効なJSONが見つからない

  }

  

  // 複数のJSONが見つかった場合は、その数を通知に含める

  const jsonCount = validJsonBlocks.length;

  

  // 通知を表示

  showJsonDetectedNotification(jsonCount);

  

  // 最後のJSONブロックを軽く強調表示

  const latestBlock = validJsonBlocks[validJsonBlocks.length - 1];

  latestBlock.style.border = '2px dashed #0078d4';

  latestBlock.style.padding = '8px';

  latestBlock.style.transition = 'all 0.3s ease';

  

  return true;

}

 

 // JSON検出通知を表示

 function showJsonDetectedNotification(count) {

   // すでに通知があれば何もしない

   if (document.querySelector('.json-detected')) return;

   

   const notification = document.createElement('div');

   notification.className = 'json-detected';

   

   if (count > 1) {

     notification.textContent = `${count}個のJSONデータを検出しました。一番下のJSONが使用されます。`;

   } else {

     notification.textContent = 'JSONデータを検出しました。拡張機能でスライド生成できます。';

   }

   

   document.body.appendChild(notification);

   

   // 表示アニメーション

   setTimeout(() => notification.classList.add('show'), 100);

   

   // 5秒後に消える

   setTimeout(() => {

     notification.classList.remove('show');

     setTimeout(() => notification.remove(), 300);

   }, 5000);

 }

 // ページからJSONデータを取得する関数

function getJsonFromPage() {

  // ページ内のすべてのJSONコードブロックを探す

  const codeBlocks = document.querySelectorAll('code.language-json, pre');

  

  // 有効なJSONを含むブロックを収集

  const validJsonBlocks = [];

  for (const block of codeBlocks) {

    try {

      const text = block.innerText || block.textContent;

      // JSONとして解析できるか確認

      JSON.parse(text);

      // 有効なJSONブロックとその位置情報を保存

      const rect = block.getBoundingClientRect();

      validJsonBlocks.push({

        text: text,

        position: rect.top + window.scrollY, // ページ上の絶対位置

        element: block

      });

    } catch (e) {

      // JSONとして解析できない場合はスキップ

      continue;

    }

  }

  

  if (validJsonBlocks.length === 0) {

    return null; // 有効なJSONが見つからない

  }

  

  // 位置情報でソート（下にあるものが後ろに来るようにする）

  validJsonBlocks.sort((a, b) => a.position - b.position);

  

  // 最後（一番下）のJSONブロックを取得

  const latestBlock = validJsonBlocks[validJsonBlocks.length - 1];

  

  // プレビューパネルが表示されている場合のみ強調表示

  const previewPanel = document.getElementById('pptx-preview-panel');

  if (previewPanel) {

    // 選択されたJSONブロックを視覚的に強調表示

    for (const block of validJsonBlocks) {

      if (block.element === latestBlock.element) {

        // 選択されたブロックを強調表示

        block.element.style.border = '3px solid #4CAF50';

        block.element.style.boxShadow = '0 0 10px rgba(76, 175, 80, 0.7)';

        // スクロールしない

      } else {

        // 他のJSONブロックは薄い強調表示

        block.element.style.border = '1px solid #0078d4';

        block.element.style.boxShadow = '0 0 5px rgba(0, 120, 212, 0.3)';

      }

    }

  }

  

  // 最新のJSONデータを返す

  return latestBlock.text;

}

 

 // ===== メッセージ処理 =====

 // メッセージ受信

 chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {

   console.log('Content script received message:', msg);

   

   // 接続確認メッセージ

   if (msg.action === 'ping') {

     console.log('Ping received');

     sendResponse({ status: 'ok' });

     return true;

   }

   

   // プレビュー表示リクエスト

   if (msg.action === 'renderPreview' && msg.pptxB64 && msg.jsonData) {

     console.log('Render preview request received');

     // Base64→Uint8Array

     const bin = atob(msg.pptxB64);

     const len = bin.length;

     const buf = new Uint8Array(len);

     for (let i = 0; i < len; i++) buf[i] = bin.charCodeAt(i);

     

     const blob = new Blob([buf.buffer], {

       type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'

     });

     

     renderPreview(blob, msg.jsonData);

     sendResponse({ status: 'ok' });

     return true;

   }

   

   // 従来の方法（互換性のため残す）

   if (msg.pptxB64) {

     console.log('Legacy preview request received');

     // Base64→Uint8Array

     const bin = atob(msg.pptxB64);

     const len = bin.length;

     const buf = new Uint8Array(len);

     for (let i = 0; i < len; i++) buf[i] = bin.charCodeAt(i);

     

     const blob = new Blob([buf.buffer], {

       type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'

     });

     

     // JSONデータがない場合は空のプレビューを表示

     renderPreview(blob, '[]');

     return true;

   }

 });

// ===== プレビューボタン関連 =====

// パネルの表示状態を追跡する変数

let isPanelVisible = false;

// プレビューボタンを追加

function injectToggleButton() {

  try {

    // すでにあればスキップ

    if (document.getElementById('pptx-preview-toggle')) return;

    

    // 必要な依存関数とオブジェクトが存在するか確認

    const dependenciesExist = 

      typeof getJsonFromPage === 'function' && 

      typeof renderPreview === 'function' && 

      typeof SlideCreator !== 'undefined' && 

      typeof PptxGenJS !== 'undefined';

    

    // スタイルを追加

    const style = document.createElement('style');

    style.textContent = `

      #pptx-preview-toggle {

        position: fixed;

        right: 0;

        top: 80%;

        transform: translateY(-80%);

        z-index: 9998;

        background: #0078d4;

        color: white;

        border: none;

        border-top-left-radius: 5px;

        border-bottom-left-radius: 5px;

        border-top-right-radius: 0;

        border-bottom-right-radius: 0;

        padding: 8px 8px;

        font-size: 14px;

        cursor: pointer;

        box-shadow: -2px 0 8px rgba(0, 0, 0, 0.2);

        transition: all 0.3s ease;

        display: flex;

        flex-direction: column;

        align-items: center;

        justify-content: center;

      }

      

      /* パネルが開いているときのボタンスタイル */

      #pptx-preview-toggle.panel-open {

        right: 30%; /* パネルの幅と同じだけ右に移動 */

      }

      

      #pptx-preview-toggle:hover {

        background: #106ebe;

        transform: translateY(-80%) translateX(-5px);

      }

      

      #pptx-preview-toggle.panel-open:hover {

        transform: translateY(-80%) translateX(-5px);

      }

      

      #pptx-preview-toggle img {

        width: 16px;

        height: auto;

        margin-top: 5px;

        transition: transform 0.3s ease;

      }

      

      #pptx-preview-toggle:hover img {

        transform: scale(1.1);

      }

      

      /* パネルが開いているときの矢印の向き */

      #pptx-preview-toggle.panel-open img {

        transform: rotate(180deg);

      }

      

      #pptx-preview-toggle.panel-open:hover img {

        transform: rotate(180deg) scale(1.1);

      }

      

      #pptx-preview-toggle .text {

        writing-mode: vertical-rl;

        text-orientation: mixed;

        margin-bottom: 8px;

        line-height: 1.2;

      }

    `;

    document.head.appendChild(style);

    

    // ボタンを作成

    const btn = document.createElement('button');

    btn.id = 'pptx-preview-toggle';

    

    // 画像のURLを取得

    const arrowImgUrl = chrome.runtime.getURL('images/Arrow.png');

    

    // ボタン内にテキストと画像を縦に配置

    btn.innerHTML = `

      <span class="text">PPT Gen</span>

      <img src="${arrowImgUrl}" alt="矢印">

    `;

    

    // ページにボタンを追加

    if (document.body) {

      document.body.appendChild(btn);

    } else {

      console.error('document.body is not available yet');

      return;

    }

    

    // クリックイベント - トグル動作に変更

    btn.addEventListener('click', async () => {

      try {

        // 既存のパネルをチェック

        const existingPanel = document.getElementById('pptx-preview-panel');

        

        if (existingPanel) {

          // パネルが既に表示されている場合は閉じる

          existingPanel.remove();

          document.body.classList.remove('pptx-preview-active');

          btn.classList.remove('panel-open');

          isPanelVisible = false;

          stopJsonAutoDetection(); // 監視を停止

          return;

        }

        

        // 依存関係のチェック

        if (!dependenciesExist) {

          console.error('必要な依存関係が見つかりません');

          alert("必要な機能が読み込まれていません。ページをリロードしてから再試行してください。");

          return;

        }

        

        // ページからJSONデータを取得

        const jsonData = getJsonFromPage();

        if (jsonData) {

          // JSONデータが見つかった場合、それを使用

          console.log('📄 [content.js] ページからJSONデータを取得:', jsonData);

          try {

            // PPTX生成

            const pptx = new PptxGenJS();

            if (!pptx) {

              throw new Error("PptxGenJSのインスタンス化に失敗しました");

            }

            pptx.defineLayout({ 

              name: 'myLayout', 

              width: SlideCreator.LAYOUT_WIDTH, 

              height: SlideCreator.LAYOUT_HEIGHT 

            });

            pptx.layout = 'myLayout';

            

            // マスター定義

            // ロゴのパスを取得（拡張機能内のリソース）

            const logoPath = chrome.runtime.getURL('logo.png');

            if (!SlideCreator.defineMasterSlide) {

              throw new Error("SlideCreator.defineMasterSlide is not a function");

            }

            const masterDefined = SlideCreator.defineMasterSlide(pptx, logoPath);

            if (!masterDefined) {

              console.warn("マスタースライドの定義に失敗しました。デフォルト設定で続行します。");

            }

            

            // JSONデータからスライドを生成

            if (!SlideCreator.createSlidesFromJson) {

              throw new Error("SlideCreator.createSlidesFromJson is not a function");

            }

            const success = SlideCreator.createSlidesFromJson(pptx, jsonData, false);

            if (!success) {

              // 失敗した場合はデフォルトのスライドを使用

              console.warn("JSONデータからのスライド生成に失敗しました。デフォルトのスライドを使用します。");

              if (!SlideCreator.getDefaultSlides) {

                throw new Error("SlideCreator.getDefaultSlides is not a function");

              }

              // デフォルトのスライドデータ

              const slideDataList = SlideCreator.getDefaultSlides();

              if (!Array.isArray(slideDataList) || slideDataList.length === 0) {

                throw new Error("デフォルトスライドデータの取得に失敗しました");

              }

              // デフォルトのスライドを追加

              slideDataList.forEach(data => {

                const slide = pptx.addSlide({ masterName: SlideCreator.MASTER_SLIDE_TITLE });

                SlideCreator.createSlideByType(slide, data, pptx, false);

              });

            }

            

            // Blob 取得→レンダー

            if (!pptx.write) {

              throw new Error("pptx.write is not a function");

            }

            const blob = await pptx.write('blob');

            if (!blob || !(blob instanceof Blob)) {

              throw new Error("Blobの生成に失敗しました");

            }

            

            // パネルを表示

            renderPreview(blob, jsonData);

            

            // ボタンの状態を更新

            btn.classList.add('panel-open');

            isPanelVisible = true;

            

          } catch (pptxError) {

            console.error('[content.js] PPTX生成エラー:', pptxError);

            alert(`PPTX生成中にエラーが発生しました: ${pptxError.message}`);

          }

        } else {

          // JSONデータが見つからない場合はデフォルトのスライドを使用

          console.log("ページからJSONデータが見つかりませんでした。デフォルトのスライドを使用します。");

          try {

            // デフォルトのスライドデータ

            if (!SlideCreator.getDefaultSlides) {

              throw new Error("SlideCreator.getDefaultSlides is not a function");

            }

            const slideDataList = SlideCreator.getDefaultSlides();

            const defaultJson = JSON.stringify(slideDataList);

            // PPTX生成

            const pptx = new PptxGenJS();

            pptx.defineLayout({ 

              name: 'myLayout', 

              width: SlideCreator.LAYOUT_WIDTH, 

              height: SlideCreator.LAYOUT_HEIGHT 

            });

            pptx.layout = 'myLayout';

            // マスター定義

            const logoPath = chrome.runtime.getURL('logo.png');

            SlideCreator.defineMasterSlide(pptx, logoPath);

            // デフォルトのスライドを追加

            slideDataList.forEach(data => {

              const slide = pptx.addSlide({ masterName: SlideCreator.MASTER_SLIDE_TITLE });

              SlideCreator.createSlideByType(slide, data, pptx, false);

            });

            // Blob 取得→レンダー

            const blob = await pptx.write('blob');

            

            // パネルを表示

            renderPreview(blob, defaultJson);

            

            // ボタンの状態を更新

            btn.classList.add('panel-open');

            isPanelVisible = true;

          } catch (defaultError) {

            console.error('[content.js] デフォルトスライド生成エラー:', defaultError);

            alert(`デフォルトスライド生成中にエラーが発生しました: ${defaultError.message}`);

          }

        }

      } catch (error) {

        console.error('[content.js] プレビュー生成エラー:', error);

        alert(`プレビュー生成中にエラーが発生しました: ${error.message}\nページをリロードしてから再試行してください。`);

      }

    });

  } catch (buttonError) {

    console.error('[content.js] ボタン作成エラー:', buttonError);

  }

}

// ===== 初期化処理 =====

// ページ読み込み完了時に実行

window.addEventListener('load', () => {

  console.log('Content script loaded');

  // プレビューボタンを追加

  injectToggleButton();

  

  // プレビューパネルが表示されている場合のみJSON検出を行う

  const previewPanel = document.getElementById('pptx-preview-panel');

  if (previewPanel) {

    detectJsonInPage();

    startJsonAutoDetection();

  }

});

// 初期化時にもプレビューボタンを追加（DOMContentLoadedより早く実行される可能性がある）

injectToggleButton();

// 一定時間後にもう一度プレビューボタンの存在を確認（非同期読み込みページ対応）

setTimeout(() => {

  if (!document.getElementById('pptx-preview-toggle')) {

    injectToggleButton();

  }

}, 2000);

